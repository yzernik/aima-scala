package aima.core.search.nondeterministic

import aima.core.search._
import scala.annotation._
import scala.Some

/**
 * Artificial Intelligence A Modern Approach (3rd Edition): Figure 4.11, page
 * 136.<br>
 * <br>
 *
 * <pre>
 * <code>
 * function AND-OR-GRAPH-SEARCH(problem) returns a conditional plan, or failure
 *   OR-SEARCH(problem.INITIAL-STATE, problem, [])
 *
 * ---------------------------------------------------------------------------------
 *
 * function OR-SEARCH(state, problem, path) returns a conditional plan, or failure
 *   if problem.GOAL-TEST(state) then return the empty plan
 *   if state is on path then return failure
 *   for each action in problem.ACTIONS(state) do
 *       plan <- AND-SEARCH(RESULTS(state, action), problem, [state | path])
 *       if plan != failure then return [action | plan]
 *   return failure
 *
 * ---------------------------------------------------------------------------------
 *
 * function AND-SEARCH(states, problem, path) returns a conditional plan, or failure
 *   for each s<sub>i</sub> in states do
 *      plan<sub>i</sub> <- OR-SEARCH(s<sub>i</sub>, problem, path)
 *      if plan<sub>i</sub> = failure then return failure
 *   return [if s<sub>1</sub> then plan<sub>1</sub> else if s<sub>2</sub> then plan<sub>2</sub> else ... if s<sub>n-1</sub> then plan<sub>n-1</sub> else plan<sub>n</sub>]
 * </code>
 * </pre>
 *
 * Figure 4.11 An algorithm for searching AND-OR graphs generated by
 * nondeterministic environments. It returns a conditional plan that reaches a
 * goal state in all circumstances. (The notation [x | l] refers to the list
 * formed by adding object x to the front of the list l.)<br>
 * <br>
 * Note: Unfortunately, this class cannot implement the interface Search
 * (core.search.framework.Search) because Search.search() returns a list of
 * Actions to perform, whereas a nondeterministic search must return a Plan.
 *
 * Author: Alex DiCarlo (dicarlo2)
 * Date: 11/20/12
 */
object andOrGraphSearch {
  def apply[S, A](problem: NDProblem[S, A]): SearchResult[OrPlan[S, A]] = {
    orSearch(problem.initialState, problem, Seq()) map { Success(_) } getOrElse Failure
  }

  private def orSearch[S, A](state: S, problem: NDProblem[S, A], path: Seq[S]): Option[OrPlan[S, A]] = {
    if (problem.goalTest(state)) return Some(new OrPlan(state, None, None))
    if (path.contains(state)) return None
    @tailrec
    def recur(actions: Seq[A]): Option[OrPlan[S, A]] = actions.headOption match {
      case Some(action) =>
        andSearch(problem.results(state, action), problem, state +: path) match {
          case plan@Some(_) => Some(new OrPlan(state, Some(action), plan))
          case None => recur(actions.tail)
        }
      case _ => None
    }
    recur(problem.actions(state))
  }

  private def andSearch[S, A](states: Seq[S], problem: NDProblem[S, A], path: Seq[S]): Option[AndPlan[S, A]] = {
    @tailrec
    def recur(states: Seq[S], planTable: Map[S, OrPlan[S, A]]): Option[AndPlan[S, A]] = states.headOption match {
      case Some(state) =>
        orSearch(state, problem, path) match {
          case Some(plan) => recur(states.tail, planTable + (state â†’ plan))
          case None => None
        }
      case None => Some(new AndPlan(planTable))
    }
    recur(states, Map[S, OrPlan[S, A]]())
  }
}
